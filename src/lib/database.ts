import { supabase } from './supabase'
import type { Child } from '../types/child'
import { sendEditLinkEmail } from './email'

export type RegistrationData = {
  guardian_name: string
  club: string | null
  email: string
  phone: string
  athletes: AthleteData[]
}

export type AthleteData = {
  first_name: string
  last_name: string
  birth_year: number
  gender: 'm' | 'w'
}

export type RegistrationResult = {
  id: string
  edit_token: string
}

/**
 * Makes the registration ID URL-safe by encoding it as base64url
 * This ensures the UUID is safe to use in URLs while maintaining security
 */
function makeSecureEditToken(registrationId: string): string {
  // Convert UUID to base64url for URL safety
  // Remove dashes and convert to base64url
  const uuidWithoutDashes = registrationId.replace(/-/g, '')
  const base64 = btoa(uuidWithoutDashes)
    .replace(/\+/g, '-')
    .replace(/\//g, '_')
    .replace(/=/g, '')
  return base64
}

export type RegistrationWithAthletes = {
  id: string
  guardian_name: string
  club: string | null
  email: string
  phone: string
  created_at: string
  athletes: Array<{
    id: string
    first_name: string
    last_name: string
    birth_year: number
    gender: 'm' | 'w'
  }>
}

/**
 * Loads a registration by edit token
 */
export async function loadRegistrationByToken(editToken: string): Promise<RegistrationWithAthletes | null> {
  const { data: registration, error } = await supabase
    .from('registrations')
    .select('*')
    .eq('edit_token', editToken)
    .single()

  if (error || !registration) {
    return null
  }

  // Load athletes
  const { data: athletes, error: athletesError } = await supabase
    .from('athletes')
    .select('*')
    .eq('registration_id', registration.id)
    .order('created_at', { ascending: true })

  if (athletesError) {
    throw new Error(`Failed to load athletes: ${athletesError.message}`)
  }

  return {
    id: registration.id,
    guardian_name: registration.guardian_name,
    club: registration.club,
    email: registration.email,
    phone: registration.phone,
    created_at: registration.created_at,
    athletes: athletes || [],
  }
}

/**
 * Updates an existing registration
 */
export async function updateRegistration(
  registrationId: string,
  data: RegistrationData
): Promise<RegistrationResult> {
  // Update the registration
  const { error: updateError } = await supabase
    .from('registrations')
    .update({
      guardian_name: data.guardian_name,
      club: data.club || null,
      email: data.email,
      phone: data.phone,
    })
    .eq('id', registrationId)

  if (updateError) {
    throw new Error(`Failed to update registration: ${updateError.message}`)
  }

  // Delete existing athletes
  const { error: deleteError } = await supabase
    .from('athletes')
    .delete()
    .eq('registration_id', registrationId)

  if (deleteError) {
    throw new Error(`Failed to delete existing athletes: ${deleteError.message}`)
  }

  // Insert new athletes
  const athletesToInsert = data.athletes.map(athlete => ({
    registration_id: registrationId,
    first_name: athlete.first_name,
    last_name: athlete.last_name,
    birth_year: athlete.birth_year,
    gender: athlete.gender,
  }))

  const { error: athletesError } = await supabase
    .from('athletes')
    .insert(athletesToInsert)

  if (athletesError) {
    throw new Error(`Failed to save athletes: ${athletesError.message}`)
  }

  // Get the edit token
  const { data: registration } = await supabase
    .from('registrations')
    .select('edit_token')
    .eq('id', registrationId)
    .single()

  return {
    id: registrationId,
    edit_token: registration?.edit_token || '',
  }
}

export async function saveRegistration(data: RegistrationData): Promise<RegistrationResult> {
  // First, insert the registration (ID will be auto-generated by database)
  const { data: registration, error: registrationError } = await supabase
    .from('registrations')
    .insert({
      guardian_name: data.guardian_name,
      club: data.club || null,
      email: data.email,
      phone: data.phone,
    })
    .select()
    .single()

  if (registrationError) {
    throw new Error(`Failed to save registration: ${registrationError.message}`)
  }

  if (!registration) {
    throw new Error('Failed to save registration: No data returned')
  }

  // Use the registration ID as edit token, but make it URL-safe
  const editToken = makeSecureEditToken(registration.id)
  
  // Update the registration with the secure edit token
  const { error: updateError } = await supabase
    .from('registrations')
    .update({ edit_token: editToken })
    .eq('id', registration.id)

  if (updateError) {
    // Rollback: delete the registration if we can't set the token
    await supabase.from('registrations').delete().eq('id', registration.id)
    throw new Error(`Failed to set edit token: ${updateError.message}`)
  }

  // Then, insert all athletes with the registration_id
  const athletesToInsert = data.athletes.map(athlete => ({
    registration_id: registration.id,
    first_name: athlete.first_name,
    last_name: athlete.last_name,
    birth_year: athlete.birth_year,
    gender: athlete.gender,
  }))

  const { error: athletesError } = await supabase
    .from('athletes')
    .insert(athletesToInsert)

  if (athletesError) {
    // Rollback: delete the registration if we can't save athletes
    await supabase.from('registrations').delete().eq('id', registration.id)
    throw new Error(`Failed to save athletes: ${athletesError.message}`)
  }

  // Try to send email with edit link - if this fails, registration is still saved
  try {
    await sendEditLinkEmail(data.email, editToken, registration.id)
  } catch (error) {
    console.error('Failed to send email, but registration was saved:', error)
    // Don't throw - registration was successful, email is optional
    // The edit link is still available and can be used
  }

  return {
    id: registration.id,
    edit_token: editToken,
  }
}

export function mapChildToAthlete(child: Child): AthleteData {
  return {
    first_name: child.vorname.trim(),
    last_name: child.nachname.trim(),
    birth_year: parseInt(child.jahrgang, 10),
    gender: child.geschlecht.toLowerCase() as 'm' | 'w',
  }
}

export function mapAthleteToChild(athlete: { first_name: string; last_name: string; birth_year: number; gender: 'm' | 'w' }): Child {
  return {
    id: crypto.randomUUID(),
    vorname: athlete.first_name,
    nachname: athlete.last_name,
    jahrgang: athlete.birth_year.toString(),
    geschlecht: athlete.gender.toUpperCase() as 'M' | 'W',
  }
}

